C51 COMPILER V9.51   DEMO                                                                  09/12/2020 08:38:36 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE DEMO
OBJECT MODULE PLACED IN demo.OBJ
COMPILER INVOKED BY: F:\Keil\C51\BIN\C51.EXE demo.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include"STC15F2K60S2.H" //头文件
   2          #include"intrins.H" //头文件
   3          #include"ctype.h"
   4          //宏定义
   5          #define uchar unsigned char        
   6          #define uint unsigned int
   7          
   8          //DS1302寄存器的定义
   9          #define DS1302_second_write  0X80
  10          #define DS1302_minutes_write  0X82
  11          #define DS1302_hour_write  0X84
  12          #define DS1302_date_write  0X86
  13          #define DS1302_week_write  0X8A
  14          #define DS1302_month_write  0X88
  15          #define DS1302_year_write  0X8C
  16          
  17          #define DS1302_second_read  0X81
  18          #define DS1302_minutes_read  0X83
  19          #define DS1302_hour_read  0X85
  20          #define DS1302_date_read  0X87
  21          #define DS1302_week_read  0X8B
  22          #define DS1302_month_read  0X89
  23          #define DS1302_year_read  0X8D
  24          
  25          //位定义
  26          sbit RTC_sclk=P1^5;//时钟控制引脚，控制数据的输入输出
  27          sbit RTC_rst=P1^6;//CE引脚，读写时必须置高电平
  28          sbit RTC_io=P5^4;//数据引脚
  29          sbit sbtKey1 = P3^2; // 按键K1
  30          sbit sbtKey2 = P3^3; // 按键K2
  31          //显示的位定义
  32          sbit led_sel=P2^3;
  33          uchar wei[]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07};    //数码管位选
  34          uchar duan[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71}; //显示0-f
  35          
  36          uint show_flag = 1; // 是否显示数码管
  37          uint sbtKey1_state = 1; // K1消抖
  38          uint sbtKey2_state = 1; // K2消抖
  39          uint Led_Value = 8; // 数码管显示位数
  40          //定义时间结构体
  41          typedef struct _systemtime_
  42          {
  43             uchar second;
  44                   uchar minute;
  45                   uchar hour;
  46                   uchar day;
  47                   uchar week;
  48                   uchar  month;
  49             uchar year;
  50          }systemtime;
  51          
  52          systemtime t;
  53                  uchar i;
  54          uchar temp;
  55          int sec=0;
C51 COMPILER V9.51   DEMO                                                                  09/12/2020 08:38:36 PAGE 2   

  56          char flag_100mS=0;
  57          
  58          //DS1302写一个字节的数据
  59          void DS1302WriteByte(uchar dat)
  60          {
  61   1              uchar i;
  62   1        RTC_sclk=0;//初始时钟线置0
  63   1              _nop_();
  64   1              _nop_();
  65   1              for(i=0;i<8;i++)//开始传输8位数据
  66   1              {
  67   2                      RTC_io=dat&0x01;//取最低位
  68   2                      _nop_();
  69   2                _nop_();
  70   2                      RTC_sclk=1;//时钟线拉高，制造上升沿，数据被传输 
  71   2                      _nop_();
  72   2                _nop_();
  73   2                      RTC_sclk=0;//时钟线拉低，为下一个上升沿做准备
  74   2                      dat>>=1;//数据右移一位，准备传输下一位数据
  75   2              }
  76   1      }
  77          
  78          ////DS1302读一个字节的数据
  79          uchar DS1302ReadByte()
  80          {
  81   1              uchar i,dat;
  82   1                      _nop_();
  83   1                _nop_();
  84   1              for(i=0;i<8;i++)
  85   1              {
  86   2                      dat>>=1;//要返回的数据右移一位
  87   2                      if(RTC_io==1)//当数据线为高时，证明该位数据为1
  88   2                      dat|=0x80;
  89   2                      RTC_sclk=1;
  90   2                      _nop_();
  91   2                _nop_();
  92   2                      RTC_sclk=0;//制造下降沿
  93   2                      _nop_();
  94   2                _nop_();
  95   2              }
  96   1              return dat;//返回读取出的数据
  97   1      }
  98          
  99          //读相应地址中写一个字节的数据
 100          uchar DS1302Read(uchar cmd)
 101          {
 102   1              uchar dat;
 103   1              RTC_rst=0;//初始CE置0
 104   1              RTC_sclk=0;//初始时钟置0
 105   1              RTC_rst=1;//初始CE置1，传输开始
 106   1              DS1302WriteByte(cmd);//传输命令字，
 107   1              dat=DS1302ReadByte();//读取得到的时间
 108   1              RTC_sclk=1;//时钟线拉高
 109   1              RTC_rst=0;//读取结束，CE置0，结束数据传输
 110   1              return dat;//返回得到的时间日期
 111   1      }
 112          
 113          //在相应地址中写数据
 114          void DS1302Write(uchar cmd,uchar dat)
 115          {
 116   1              RTC_rst=0;//初始CE置0
 117   1              RTC_sclk=0;//初始时钟置0
C51 COMPILER V9.51   DEMO                                                                  09/12/2020 08:38:36 PAGE 3   

 118   1              RTC_rst=1;//置1，传输开始
 119   1              DS1302WriteByte(cmd);//传输命令字，要写入的时间的地址
 120   1              DS1302WriteByte(dat);//写入修改的时间
 121   1              RTC_sclk=1;//时钟线拉高
 122   1              RTC_rst=0;//读取结束，CE=0，结束数据的传输
 123   1      }
 124          //DS1302的时间值获取程序
 125          systemtime GetDA1302()
 126          {
 127   1              systemtime time;
 128   1              uchar realvalue;
 129   1              realvalue=DS1302Read(DS1302_second_read);
 130   1              time.second=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 131   1                      realvalue=DS1302Read(DS1302_minutes_read);
 132   1              time.minute=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 133   1                      realvalue=DS1302Read(DS1302_hour_read );
 134   1              time.hour=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 135   1                      realvalue=DS1302Read(DS1302_date_read );
 136   1              time.day=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 137   1                      realvalue=DS1302Read(DS1302_week_read);
 138   1              time.week=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 139   1                      realvalue=DS1302Read(DS1302_month_read);
 140   1              time.month=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 141   1                              realvalue=DS1302Read(DS1302_year_read);
 142   1              time.year=((realvalue&0x70)>>4)*10+(realvalue&0x0f);
 143   1              return time;
 144   1      }
 145          //DS1302初始化程序
 146          void Init_DS1302()
 147          {       unsigned char hour,min,sec;
 148   1      //    unsigned char code DataStr[]=__DATE__;      //格式: "Jan 13 2017"   12字符（含结束符）
 149   1          unsigned char code DataStr[]=__TIME__;        //格式："09:12:04"      9字符（含结束符）
 150   1      
 151   1          hour=((toint(DataStr[0]))<<4)+toint(DataStr[1]);
 152   1              min=((toint(DataStr[3]))<<4)+toint(DataStr[4]);
 153   1              sec=((toint(DataStr[6]))<<4)+toint(DataStr[7]);
 154   1      
 155   1              DS1302Write(0X8E,0X00);//写保护关
 156   1              DS1302Write(DS1302_second_write,sec);
 157   1              DS1302Write(DS1302_minutes_write,min);
 158   1              DS1302Write(DS1302_hour_write,hour);
 159   1      //    DS1302Write(DS1302_week_write,0X00);
 160   1      //      DS1302Write(DS1302_month_write,0X00);
 161   1      //      DS1302Write(DS1302_date_write,0X00);
 162   1      //      DS1302Write(DS1302_year_write,0X00);
 163   1              temp=DS1302Read(DS1302_second_read)&0x7f;
 164   1              DS1302Write(DS1302_second_write,temp);
 165   1      //      DS1302Write(0x90,0xa9);         //  充电设置：允许充电，2个二极管，2K电 
 166   1              DS1302Write(0X8E,0X80);//写保护置1
 167   1      }
 168          
 169           void set_charge_DS1302()
 170          { 
 171   1              DS1302Write(0X8E,0X00); //写保护关
 172   1              DS1302Write(0x90,0xa9); //  充电设置：允许充电，2个二极管，2K电 
 173   1              DS1302Write(0X8E,0X80); //写保护置1
 174   1      }
 175          
 176          //系统初始化程序
 177          void init()
 178          {       P3=0xEF;                                  //关蜂鸣器
 179   1              P2M0=0XFF;
C51 COMPILER V9.51   DEMO                                                                  09/12/2020 08:38:36 PAGE 4   

 180   1              P2M1=0X00;
 181   1              P0M0=0XFF;
 182   1              P0M1=0X00;
 183   1      
 184   1              led_sel=0;//选通数码管
 185   1              TMOD=0X01;//定时器0，工作方式1
 186   1              EA=1;//打开总中断
 187   1              TH0=(65535-500)/256;//设置定时初值
 188   1              TL0=(65535-500)%256;
 189   1              TR0=1;//启动定时器
 190   1              ET0=1;//开启定时器中断
 191   1      }
 192          
 193          void time0() interrupt 1
 194          {
 195   1              TH0=(65535-500)/256;//设置定时初值
 196   1              TL0=(65535-500)%256;
 197   1              EA=0;
 198   1              i++;
 199   1              if(++sec==100) {sec=0; flag_100mS=1; }
 200   1              if(i == Led_Value)
 201   1                      i=0;
 202   1              led_sel=0;
 203   1              P0=0X00;
 204   1              if (show_flag == 1 && i < 8) {  
 205   2                      P2=wei[i];      
 206   2                      switch(i)
 207   2                      {
 208   3                              case 0:P0=duan[t.hour/10];break;
 209   3                              case 1:P0=duan[t.hour%10];break;
 210   3                              case 3:P0=duan[t.minute/10];break;
 211   3                              case 4:P0=duan[t.minute%10];break;
 212   3                              case 6:P0=duan[t.second/10];break;
 213   3                              case 7:P0=duan[t.second%10];break;
 214   3                              default :P0=0x40;break;
 215   3                      }
 216   2              }
 217   1              EA=1;
 218   1      }
 219          void Delay10ms()                //@11.0592MHz
 220          {
 221   1              unsigned char i, j;
 222   1      
 223   1              i = 108;
 224   1              j = 145;
 225   1              do
 226   1              {
 227   2                      while (--j);
 228   2              } while (--i);
 229   1      }
 230          void main()
 231          {
 232   1              init();
 233   1              if(DS1302Read(DS1302_second_read)&0X80) Init_DS1302();
 234   1              set_charge_DS1302();
 235   1              while(1)
 236   1              {
 237   2                      if (sbtKey1 == 0) {
 238   3                              if (sbtKey1_state == 0) {
 239   4                                      Delay10ms();
 240   4                                      if (sbtKey1 == 0) {
 241   5                                              show_flag = ~show_flag;
C51 COMPILER V9.51   DEMO                                                                  09/12/2020 08:38:36 PAGE 5   

 242   5                                              sbtKey1_state = 1;
 243   5                                      }
 244   4                              }
 245   3                      }else sbtKey1_state = 0;
 246   2                      if (sbtKey2 == 0) {
 247   3                              if (sbtKey2_state == 0) {
 248   4                                      Delay10ms();
 249   4                                      if (sbtKey2 == 0) {
 250   5                                              Led_Value += 4;
 251   5                                              sbtKey2_state = 1;
 252   5                                      }
 253   4                              }
 254   3                      }else sbtKey2_state = 0;
 255   2      
 256   2                      if (flag_100mS==1)
 257   2                      {
 258   3                               t=GetDA1302();
 259   3                               flag_100mS=0;
 260   3                      }
 261   2              }
 262   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    723    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     44       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
